# 通信层（Communication Layer）模块文档

## 1. 模块概述

通信层是系统的最底层模块，负责与下位机建立TCP连接，接收和解析FFT数据包，实现包同步和帧重组功能。

**文件位置**：`Software/communication.py`

**主要职责**：
- 管理TCP Socket连接
- 实现基于魔数的包同步机制
- 解析数据包并重组为完整FFT帧
- 检测丢包并记录日志
- 将完整帧放入队列供数据处理层使用

---

## 2. 技术实现

### 2.1 核心技术

| 技术 | 用途 |
|------|------|
| Python Socket | TCP网络通信 |
| struct | 二进制数据打包/解包 |
| threading | 接收线程 |
| numpy | FFT数据数组处理 |
| queue | 与数据处理层的数据传递 |

### 2.2 依赖关系

```
Communication
    ├─ depends on: State（状态管理）
    ├─ depends on: queue.Queue（数据队列）
    └─ provides: FFT数据流
```

---

## 3. 类设计

### 3.1 Communication类

```python
class Communication:
    def __init__(self, state, fft_data_queue):
        """
        Args:
            state: 系统状态对象
            fft_data_queue: FFT数据队列（与数据处理层共享）
        """
```

### 3.2 核心属性

```python
# 网络连接
self.socket: socket.socket              # TCP Socket对象
self.receive_thread: Thread             # 接收线程

# 数据缓冲
self.buffer: bytearray                  # 原始数据缓冲区
self.current_frame_buffer: bytearray    # 当前帧缓冲区

# 协议参数
self.PACKET_MAGIC = 0xAABBCCDD         # 包同步魔数
self.expected_fft_length = 1024         # 期望的FFT长度
self.bytes_per_sample = 4               # 每个采样点字节数（float32）
self.expected_packets_per_frame = 8     # 每帧包数

# 状态跟踪
self.last_packet_id: int                # 上一个包ID
self.frame_count: int                   # 接收到的完整帧计数
```

---

## 4. 核心方法

### 4.1 连接管理

#### connect(ip, port)

```python
def connect(self, ip, port):
    """
    建立TCP连接
    
    功能：
    1. 创建Socket并连接到指定地址
    2. 设置接收缓冲区大小（1MB）
    3. 启动接收线程
    4. 更新State状态
    
    Returns:
        bool: 连接成功返回True，失败返回False
    """
```

**实现细节**：
```python
self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
self.socket.connect((ip, port))
self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 1024 * 1024)

# 启动守护线程
self.receive_thread = threading.Thread(target=self._receive_loop, daemon=True)
self.receive_thread.start()

# 更新状态（会触发信号）
self.state.communication_thread = True
```

#### disconnect()

```python
def disconnect(self):
    """
    断开TCP连接
    
    功能：
    1. 更新状态（停止接收线程）
    2. 关闭Socket
    3. 清理资源
    """
```

### 4.2 数据接收

#### _receive_loop()

```python
def _receive_loop(self):
    """
    接收线程主循环
    
    流程：
    1. 搜索魔数，确保包同步
    2. 读取包头（packet_id, data_length）
    3. 接收实际数据
    4. 检测新帧开始（packet_id == 0）
    5. 检测丢包（packet_id不连续）
    6. 添加到帧缓冲
    7. 检查帧完整性，完整则处理
    
    异常处理：
    - 同步失败：退出循环
    - 接收失败：记录日志并继续
    - 其他异常：记录完整堆栈信息
    """
```

**伪代码**：
```python
while state.communication_thread:
    # 步骤1：同步到魔数
    if not _sync_to_magic():
        break
    
    # 步骤2：读取包头
    packet_id, data_length = unpack(recv(8))
    
    # 步骤3：接收数据
    data = _recv_exact(data_length)
    
    # 步骤4：检测新帧
    if packet_id == 0:
        _process_frame(current_frame_buffer)
        current_frame_buffer.clear()
    
    # 步骤5：检测丢包
    if packet_id != last_packet_id + 1:
        log_warning("丢失了 X 个包")
    
    # 步骤6：添加到缓冲
    current_frame_buffer.extend(data)
    
    # 步骤7：检查完整性
    if len(current_frame_buffer) >= expected_size:
        _process_frame(current_frame_buffer)
```

### 4.3 包同步

#### _sync_to_magic()

```python
def _sync_to_magic(self):
    """
    搜索魔数以实现包同步
    
    算法：
    1. 维护4字节滑动窗口
    2. 逐字节读取数据
    3. 检查窗口是否匹配魔数
    4. 匹配成功返回True
    
    特点：
    - 即使丢包也能重新同步
    - 对任意位置的数据流都能找到边界
    
    Returns:
        bool: 找到魔数返回True，否则返回False
    """
```

**实现原理**：
```python
magic_bytes = struct.pack(">I", 0xAABBCCDD)  # [AA, BB, CC, DD]
sync_buffer = bytearray()  # 滑动窗口

while True:
    byte = socket.recv(1)
    sync_buffer.append(byte[0])
    
    # 保持窗口为4字节
    if len(sync_buffer) > 4:
        sync_buffer.pop(0)  # 移除最旧的字节
    
    # 检查匹配
    if len(sync_buffer) == 4 and bytes(sync_buffer) == magic_bytes:
        return True  # 找到魔数
```

**可视化**：
```
接收数据流： ... 45 67 AA BB CC DD 00 01 ...
                    ↑
滑动窗口第1次：[45 67 AA]
滑动窗口第2次：[67 AA BB]
滑动窗口第3次：[AA BB CC]
滑动窗口第4次：[AA BB CC DD] ← 匹配成功！
```

### 4.4 精确接收

#### _recv_exact(num_bytes)

```python
def _recv_exact(self, num_bytes):
    """
    精确接收指定字节数的数据
    
    问题：socket.recv()可能一次接收不完整
    解决：循环接收直到达到指定字节数
    
    Args:
        num_bytes: 需要接收的字节数
    
    Returns:
        bytes: 接收到的数据，失败返回None
    """
```

**实现**：
```python
data = bytearray()
while len(data) < num_bytes:
    packet = self.socket.recv(num_bytes - len(data))
    if not packet:  # 连接断开
        return None
    data.extend(packet)
return bytes(data)
```

### 4.5 帧处理

#### _process_frame(frame_data)

```python
def _process_frame(self, frame_data):
    """
    处理完整的FFT帧
    
    功能：
    1. 检查帧完整性
    2. 转换为numpy数组
    3. 构造数据字典
    4. 放入队列
    5. 队列满时处理溢出
    
    Args:
        frame_data: 完整帧的字节数据
    """
```

**数据格式转换**：
```python
# 1. 检查大小
expected_size = 1024 * 4  # 4096 bytes
if len(frame_data) < expected_size:
    log_warning("帧不完整，丢弃")
    return

# 2. 解析为numpy数组
fft_data = np.frombuffer(frame_data[:expected_size], dtype=np.float32)

# 3. 构造数据包
data_packet = {
    "timestamp": time.time(),
    "data": fft_data,
    "length": len(fft_data),
    "frame_id": self.frame_count
}

# 4. 放入队列（非阻塞）
try:
    self.fft_data_queue.put_nowait(data_packet)
    self.frame_count += 1
except queue.Full:
    # 队列满，丢弃最旧数据
    self.fft_data_queue.get_nowait()
    self.fft_data_queue.put_nowait(data_packet)
```

---

## 5. 通信协议

### 5.1 数据包格式

```
+----------------+----------------+----------------+------------------+
|     Magic      |   Packet ID    |  Data Length   |      Data        |
|   (4 bytes)    |   (4 bytes)    |   (4 bytes)    |   (variable)     |
+----------------+----------------+----------------+------------------+
|  0xAABBCCDD    |     0-7        |      512       | 128 * float32    |
+----------------+----------------+----------------+------------------+
```

**字段详解**：

| 字段 | 类型 | 字节序 | 说明 |
|------|------|--------|------|
| Magic | uint32 | Big-endian | 固定值0xAABBCCDD，用于包同步 |
| Packet ID | uint32 | Big-endian | 包序号（0-7），帧内唯一 |
| Data Length | uint32 | Big-endian | 数据部分字节数（固定512） |
| Data | float32[] | Native | 128个FFT采样点 |

**打包/解包**：
```python
# 打包（发送端）
header = struct.pack(">III", 0xAABBCCDD, packet_id, data_length)

# 解包（接收端）
packet_id, data_length = struct.unpack(">II", header)
```

### 5.2 帧结构

一个完整的FFT帧由8个包组成：

```
帧结构：
┌─────────┬─────────┬─────────┬───────┬─────────┐
│ Packet0 │ Packet1 │ Packet2 │  ...  │ Packet7 │
└─────────┴─────────┴─────────┴───────┴─────────┘
   128点      128点      128点            128点
   
   = 1024点完整FFT数据
```

**时序关系**：
```
Packet0 (0ms)    → Magic + ID=0 + Data[0:128]
Packet1 (1ms)    → Magic + ID=1 + Data[128:256]
Packet2 (2ms)    → Magic + ID=2 + Data[256:384]
...
Packet7 (7ms)    → Magic + ID=7 + Data[896:1024]

新帧开始 (10ms) → Magic + ID=0 + Data[0:128]
```

### 5.3 丢包检测机制

**检测方法**：
```python
if packet_id != last_packet_id + 1:
    lost_count = packet_id - last_packet_id - 1
    logging.warning(f"丢失 {lost_count} 个包")
```

**处理策略**：
1. **记录日志**：记录丢包数量和位置
2. **继续接收**：不中断当前帧接收
3. **完整性检查**：帧结束时检查总字节数
4. **丢弃不完整帧**：字节数不足则丢弃整帧
5. **自动恢复**：下一帧通过魔数重新同步

**示例场景**：
```
期望序列： 0 → 1 → 2 → 3 → 4 → 5 → 6 → 7
实际接收： 0 → 1 → 2 → [丢失] → 5 → 6 → 7
              ↑
检测到丢包：packet_id=5, last=2, lost=2个包
结果：缓冲区字节数 = 512*6 = 3072 < 4096
     → 丢弃该帧
     → 下一帧从ID=0重新开始
```

---

## 6. 状态管理

### 6.1 状态变量

通信层通过State对象管理运行状态：

```python
self.state.communication_thread: bool
    - True: 线程运行中，持续接收数据
    - False: 线程停止，退出接收循环
```

### 6.2 状态更新

```python
# 连接成功
self.state.communication_thread = True
# ↓ 触发
# State.connection_changed.emit(True)
# ↓ 通知
# UI更新开关状态

# 断开连接
self.state.communication_thread = False
# ↓ 触发
# State.connection_changed.emit(False)
# ↓ 通知
# UI更新开关状态
```

---

## 7. 线程安全

### 7.1 线程模型

```
接收线程（Communication Thread）
    ↓ 数据流
Queue（线程安全）
    ↓ 数据流
处理线程（Processing Thread）
```

### 7.2 安全机制

1. **Queue内置线程安全**：
   ```python
   queue.Queue.put_nowait()  # 原子操作
   queue.Queue.get_nowait()  # 原子操作
   ```

2. **状态更新通过信号**：
   ```python
   self.state.communication_thread = value  # PyQt信号机制（线程安全）
   ```

3. **线程退出机制**：
   ```python
   # 主线程设置标志
   self.state.communication_thread = False
   
   # 接收线程检查标志
   while self.state.communication_thread:
       # 接收数据
   
   # 自动退出循环
   ```

---

## 8. 错误处理

### 8.1 连接错误

```python
try:
    self.socket.connect((ip, port))
except ConnectionRefusedError:
    logging.error("连接被拒绝，检查设备是否启动")
    self.state.communication_thread = False
except socket.timeout:
    logging.error("连接超时")
    self.state.communication_thread = False
except Exception as e:
    logging.error(f"连接失败: {e}", exc_info=True)
    self.state.communication_thread = False
```

### 8.2 接收错误

```python
try:
    data = self.socket.recv(num_bytes)
    if not data:  # 连接断开
        logging.error("连接断开")
        return None
except socket.timeout:
    logging.warning("接收超时，继续等待...")
    continue
except Exception as e:
    logging.error(f"接收错误: {e}")
    return None
```

### 8.3 数据解析错误

```python
try:
    packet_id, data_length = struct.unpack(">II", header)
except struct.error as e:
    logging.error(f"包头解析失败: {e}")
    continue  # 跳过当前包，继续同步
```

---

## 9. 性能优化

### 9.1 缓冲区设置

```python
# 设置Socket接收缓冲区为1MB
self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 1024 * 1024)
```

**原因**：
- 防止网络抖动导致数据丢失
- 提供足够的缓冲空间
- 1MB可缓冲约250帧数据

### 9.2 非阻塞队列操作

```python
# 使用put_nowait而非put（避免阻塞）
self.fft_data_queue.put_nowait(data_packet)
```

**优势**：
- 不阻塞接收线程
- 队列满时立即处理
- 保证实时性

### 9.3 字节数组优化

```python
# 使用bytearray而非bytes（可变）
self.current_frame_buffer = bytearray()
self.current_frame_buffer.extend(data)  # 原地扩展，无需复制
```

---

## 10. 接口定义

### 10.1 对外接口

```python
class Communication:
    def connect(self, ip: str, port: int) -> bool:
        """建立连接"""
        
    def disconnect(self) -> None:
        """断开连接"""
        
    def send_command(self, command: str) -> bool:
        """发送命令到下位机（预留）"""
```

### 10.2 数据接口

**输出到数据处理层**：
```python
# 通过Queue传递
data_packet = {
    "timestamp": float,      # 接收时间戳
    "data": np.ndarray,     # FFT数据（1024个float32）
    "length": int,          # 数据长度
    "frame_id": int         # 帧序号
}
```

---

## 11. 测试建议

### 11.1 单元测试

```python
def test_sync_to_magic():
    """测试魔数同步功能"""
    # 构造包含魔数的数据流
    # 验证能否正确找到魔数
    
def test_packet_parsing():
    """测试包解析功能"""
    # 构造标准数据包
    # 验证解析结果正确性
    
def test_frame_reassembly():
    """测试帧重组功能"""
    # 发送完整的8个包
    # 验证能否重组为完整帧
    
def test_packet_loss_detection():
    """测试丢包检测"""
    # 发送不连续的包序列
    # 验证能否检测到丢包
```

### 11.2 集成测试

```python
def test_with_mock_device():
    """使用模拟设备测试"""
    # 启动MockDevice
    # 连接并接收数据
    # 验证数据正确性
    
def test_reconnection():
    """测试重连功能"""
    # 建立连接
    # 断开连接
    # 重新连接
    # 验证状态正确
```

---

## 12. 使用示例

```python
# 1. 创建State和Queue
state = State()
fft_queue = queue.Queue(maxsize=5)

# 2. 创建Communication实例
comm = Communication(state, fft_queue)

# 3. 连接设备
success = comm.connect("192.168.1.100", 5000)
if success:
    print("连接成功")
    
# 4. 数据会自动接收并放入队列
# 其他模块从队列获取数据
while True:
    data_packet = fft_queue.get()
    process_data(data_packet)

# 5. 断开连接
comm.disconnect()
```

---

## 13. 常见问题

### Q1: 为什么使用魔数而不是固定包头？

**A**: 魔数提供更强的同步能力：
- 可以从数据流的任意位置开始同步
- 即使丢包也能重新找到边界
- 实现简单，开销小

### Q2: 丢包后如何恢复？

**A**: 自动恢复机制：
1. 检测到丢包，记录日志
2. 继续接收当前帧剩余包
3. 帧不完整，丢弃该帧
4. 下一帧packet_id=0，通过魔数重新同步
5. 恢复正常接收

### Q3: 为什么不用UDP？

**A**: TCP更适合本场景：
- 数据完整性要求高（FFT数据不能有误）
- 局域网环境，TCP开销可接受
- TCP提供流控和拥塞控制
- 如果需要更低延迟，后续可改为UDP+自定义可靠性机制

### Q4: Queue满了怎么办？

**A**: 丢弃最旧数据：
```python
try:
    queue.put_nowait(new_data)
except queue.Full:
    queue.get_nowait()  # 丢弃最旧
    queue.put_nowait(new_data)  # 放入最新
```

这保证了实时性，牺牲了部分历史数据。

---

## 14. 总结

通信层是系统的基础模块，实现了稳定可靠的数据接收功能：

**核心特点**：
- ✅ 基于魔数的包同步机制
- ✅ 完善的丢包检测和恢复
- ✅ 线程安全的数据传递
- ✅ 清晰的错误处理

**设计优势**：
- 模块独立，易于测试
- 接口简洁，易于使用
- 健壮性强，容错能力好
- 性能优化，满足实时要求
